# Node 框架设计文档

## 1. 任务定义

**计算节点 (Node)** 由三个要素完全决定：

1. **函数**：计算逻辑
2. **参数**：影响计算的所有参数
3. **依赖**：上游节点的计算结果

只要这三者相同，就是同一个计算，应该得到相同的结果。

计算节点的组合构成数据管线，依赖关系形成有向无环图（DAG）。

---

## 2. 设计目标

框架旨在解决传统数据管线的以下问题：

**1. 缓存难以管理**

- 每个节点都要写重复的缓存逻辑（缓存键定义、读写、失效判断）
- 缓存键要包含上游依赖，构造复杂

**2. 结果无法追溯**

- 缓存键不完整则无法识别计算结果来源
- 即使缓存键完整，也无法追溯到具体执行代码

**3. 配置注入繁琐**

- 大型管线配置多且难以管理
- 不同配置组合切换繁琐

**4. 批量计算重复**

- 对多个参数值执行相同计算需要手动循环
- 循环内各计算无法并行、无法独立缓存

---

## 3. 解决方案

### 3.1 自动缓存

框架根据函数名、参数值、依赖节点缓存键生成唯一标识，自动处理缓存的读写和失效：

```
缓存键 = hash(函数名 + 参数值 + 依赖节点缓存键)
```

特性：
- 参数或依赖变化自动触发重算
- 支持多级缓存（内存 → 磁盘）
- 可禁用缓存或排除特定参数

### 3.2 可追溯执行

每个节点可通过 `repr()` 生成可执行的 Python 脚本：

```python
print(repr(result))
# hash = 7c3b8fad541e11
# add_0 = add(x=2, y=3)
# square_0 = square(n=add_0)
```

磁盘缓存自动保存脚本，支持复现历史结果。

### 3.3 配置系统

通过 YAML 集中管理参数：

- **参数注入**：配置中与函数同名的节自动注入为默认参数
- **变量引用**：`${...}` 引用其他配置项
- **节点依赖**：`_target_` 指定函数路径，`${node}` 自动构建依赖
- **预设切换**：`_presets_` 定义多套配置，运行时切换

### 3.4 并行调度

框架自动分析 DAG 依赖关系，无依赖的节点并行执行：

- **执行器**：支持线程池和进程池
- **节点级控制**：可限制特定函数的并发数
- **菱形依赖**：共享上游节点只执行一次

```
    A
   / \
  B   C    → A 执行一次，B/C 并行，D 等待 B/C 完成
   \ /
    D
```

### 3.5 多维计算

遍历参数的多个取值，自动执行所有组合：

```python
@node.dimension()
def time():
    return [2020, 2021, 2022]

@node.define()
def load(t):
    return pd.read_csv(f"{t}.csv")

data = load(t=time())  # 自动展开为 3 个独立计算
```

特性：
- **广播**：不同维度自动计算笛卡尔积
- **对齐**：相同维度自动 zip 对齐
- **聚合**：`reduce_dims` 归约指定维度
- 每个标量节点独立缓存、可并行

---

## 4. 设计原则

### 4.1 纯函数

节点函数必须是纯函数（相同输入 → 相同输出），以保证缓存正确性。

### 4.2 声明式

用户只需声明计算逻辑和依赖关系，框架自动处理执行顺序、缓存、并行。

### 4.3 可复现

任何计算结果都可以通过脚本完整复现，无需依赖框架运行时。

### 4.4 最小侵入

使用装饰器而非继承，普通 Python 函数即可成为节点，降低迁移成本。
